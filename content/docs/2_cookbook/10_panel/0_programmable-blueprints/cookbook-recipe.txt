Title: Programmable blueprints

----

Published: 2021-08-07

----

Description: Create blueprints programmatically with PHP

----

Authors: - authors/sonja-broda

----
Text:

## Intro

Blueprints for Panel forms are usually static YAML files. While this is totally fine for most use cases, there are some situations where we wish we had a more dynamic way of creating blueprints.

In a Kirby plugin, we can (link: docs/reference/plugins/extensions/blueprints text: register blueprints) inside the blueprints array as key/value pairs, where the key is the name of the blueprint. As values we can either provide the path to a file or we can pass the blueprint definition as an array.

So why not return this array via PHP?

This approach works for complete page/user/file blueprints as well as for partial blueprints like tabs, fieldgroups etc.

<info>
Since we don't have access to the current page object in the PHP blueprint files and therefore have to hard-code the pages we want to fetch via PHP, the possibilities we have with this type of setup are a bit limited but might come in handy in certain scenarios.
</info>

## Prerequisites

- A running Kirby (link: text: StarterKit)
- The (link: text: Pagesdisplay section plugin) installed, for page sections example



## Page blueprint with filtered pages sections

A typical situation that has come up multiple times in support are dynamic numbers of pages sections that filter pages by category. Since the number of categories is usually not set in stone from the outset but new categories might be added any time, we cannot possibly set up all sections in advance. In such a use case, being able to create those sections dynamically is a big plus.

First, let's create a new plugin folder called `programmable-blueprints` in `/site/plugins/` with its obligatory `index.php` file.

Inside this `index.php` file, we register a pages blueprint called `notes`and include the `notes.php` file which we have yet to create.

```php "/site/plugins/programmable-blueprints/index.php"
<?php

use Kirby\Cms\App as Kirby;

Kirby::plugin('cookbook/programmable-blueprints', 
[
  'blueprints' => [
    'pages/notes' => include __DIR__ . '/blueprints/pages/notes.php'
  ],
]);
```

Now create a new subfolder structure `blueprints/pages` and inside the `pages` folder the `notes.php` file with the following code:


```php "/site/plugins/programmable-blueprints/blueprints/pages/notes.php"
<?php

$sections = [];
if ($page = page('notes')) {
    // create a new section array for each unique tag plucked from the children pages
    foreach ($page->children()->pluck('tags', ',', true) as $tag) {
        $sections['section_' . $tag] = [
            'type'     => 'pagesdisplay',
            'headline' => 'Pages with tag ' . $tag,
            // note the required quotes around the `$tag` variable
            'query'    => "page.children.filterBy('tags', '". $tag . "', ',')", 
        ];
    }
}

// create the array for the page blueprint with two columns
$yaml = [
    'title'   => 'Notes',
    'options' => [
        'changeStatus' => false,
        'changeSlug'   => false
    ],
    'columns' => [
        'sidebar' => [
            'width'    => '1/3',
            'sections' => [
              'drafts' => [
                'type'     => 'pages',
                'headline' => 'Drafts',
                'status'   => 'drafts',
                ]
            ],
        ],
        'main' => [
            'width'    => '2/3',
            'sections' => $sections, // dynamically generated sections from above
        ]
    ]
];

return $yaml;
```

To use this blueprint, remove the original `/site/blueprints/pages/notes.yml` file. 

As a result, we will end up with as many sections as we have tags (and in this example, there will be only one page per section, because all tags are only used once). For the screenshot I've reassigned the tags, so that the result looks less silly:

(image: programmable-blueprints.png)

<info>
Note that we have set `changeSlug` to `false`, because the blueprint would stop working if the page was renamed.
</info>


## Field group with dynamic fields

The same kind of logic will work for dynamic fields, for example if you wanted to create a number of pages fields where users can select one (or more) pages from each parent.

Again, we first register the new blueprint:

```php "/site/plugins/programmable-blueprints/index.php"
<?php

use Kirby\Cms\App as Kirby;

Kirby::plugin('cookbook/programmable-blueprints', 
[
    'blueprints' => [
        'pages/notes'         => include __DIR__ . '/blueprints/pages/notes.php'
        'fields/multiselects' => include __DIR__ . '/blueprints/fields/multiselects.php'
    ],
]);
```

And then create a fieldgroup called `multiselects` in the given path:

```php "/site/plugins/programmable-blueprints/blueprints/fields/multiselects.php"
<?php

$fields = [];

foreach (site()->children()->filterBy('template', 'in', ['notes', 'photography']) as $page) {
    $fields[$page->slug()] = [
        'label'   => $page->title()->value(),
        'type'    => 'pages',
        'query'   => 'site.find("' . $page->slug() . '").children',
        'min'     => 1,
        'max'     => 1,
    ];
}

return [
    'type'   => 'group',
    'fields' => $fields,
];
```

In a page/user/file blueprint, we can now use this field group like this:

```yaml
fields:
  type: fields
  fields:
    extends: fields/multiselects
```

(image: dynamic-fields.png)

## Assigning filtered blueprints to sections

When you want to assign allowed templates to a pages section, you have to list them out one by one. Not with our programmatic approach.

Again, we register a new section blueprint:

```php "/site/plugins/programmable-blueprints/index.php"

Kirby::plugin('cookbook/programmable-blueprints', 
[
    'blueprints' => [
        'pages/notes'         => include __DIR__ . '/blueprints/pages/notes.php',
        'fields/multiselects' => include __DIR__ . '/blueprints/fields/multiselects.php',
        'sections/notes'      => include __DIR__ . '/blueprints/sections/notes.php',
    ],
]);

```

And create `/blueprints/sections/notes.php` with the following code:

```php "/site/plugins/programmable-blueprints/blueprints/sections/notes.php"
<?php
$blueprints = kirby()->blueprints();
$blueprints = array_filter($blueprints, function($blueprint) {
  return in_array($blueprint, ['error', 'home', 'about']) === false;
});

return [
  'type'      => 'pages',
  'parent'    => "kirby.page('notes')",
  'headline'  => 'Notepages',
  'info'      => '{{ page.files.count }}',
  'templates' => $blueprints,
];
```

We remove all unwanted blueprints from the `$blueprints` array and assign the rest to the section's `templates` prop.

If we need the same set of blueprints for multiple sections, we can return the filtered set from its own blueprint and include it in our PHP pages/sections blueprints:

From `blueprints.php` we now only return an array of blueprints:

```php "/site/plugins/programmable-blueprints/blueprints/options/blueprints.php"
<?php

$blueprints = kirby()->blueprints();
return array_filter($blueprints, function($blueprint) {
  return in_array($blueprint, ['error', 'home', 'about']) === false;
});
```

And load this array for example in the `notes.php` section:

```php "/site/plugins/programmable-blueprints/blueprints/sections/notes.php"
return [
  'type'      => 'pages',
  'parent'    => "kirby.page('notes')",
  'headline'  => 'Notepages',
  'info'      => '{{ page.files.count }}',
  'templates' => include __DIR__ . '/../options/blueprints.php',
];
```

<info>
We don't have to register `options/blueprints.php`, because we cannot use it like a normal extension but have to explicitly include it.
</info>

## Tabs

In this last example, we register a (link: docs/guide/blueprints/tabs text: tab blueprint).


```php "/site/plugins/programmable-blueprints/index.php"
<?php

use Kirby\Cms\App as Kirby;

Kirby::plugin('cookbook/programmable-blueprints', 
[
    'blueprints' => [
        'pages/notes'         => include __DIR__ . '/blueprints/pages/notes.php',
        'fields/multiselects' => include __DIR__ . '/blueprints/fields/multiselects.php',
        'sections/notes'      => include __DIR__ . '/blueprints/sections/notes.php',
        'tab/meta'            => include __DIR__ . '/blueprints/tabs/meta.php',
    ],
]);
```

Let's assume we already had a basic `yml` blueprint that we wanted to extend programmatically.


This is our basic blueprint, which we put into `blueprints/tabs` folder for simplicity.

```yml "/site/plugins/programmable-blueprints/blueprints/tabs/basic-meta.yml"
label: Meta
icon: search

sections:
  basicMeta:
    type: fields
    fields:
      metaHeadline:
        label: Basic Meta Information
        type: headline
        numbered: false
      metaTitle:
        label: Title (Override)
        type: text
      metaDescription:
        label: Description
        type: text
      metaCanonicalUrl:
        label: Canonical URL
        type: url
      metaAuthor:
        label: Author/s
        type: text
      metaImage:
        label: Image
        type: files
        multiple: false
      metaPhoneNumber:
        label: Phone Number
        type: text
```

How can we extend this via PHP? In the same folder, let's create the `meta.php` file we already registered above and put in the following code:


```php "/site/plugins/programmable-blueprints/blueprints/tabs/meta.php"
<?php
use Kirby\Data\Data;

$basic_blueprint = Data::read(__DIR__ . '/seo-basic.yml', 'yaml');
$basic_blueprint['label'] = 'SEO';
$fields = $basic_blueprint['sections']['basicMeta']['fields'];
$basic_blueprint['sections']['basicMeta']['fields'] = array_merge($fields, [
    'twitterHandle' => [
        'label' => 'Twitter handle',
        'type' => 'text',
    ]
]);
 
return $basic_blueprint;
```

First, we read the basic file we want to extend into an array with `Data::read()`.

Then we change the tab label and add a new field in the `basicMeta` section, by merging the original fields array with the new `twitterHandle` field.

We can now add this tab in our page blueprints:

```yml
Title: Some page blueprint

tabs:
  tab1:
    label: Content
    # code for tab1 here
  tab2: tabs/meta
```

## Recap

In this recipe we looked into creating different types of blueprints dynamically, which can be helpful in several use cases. And if you don't like `YAML`, it might even become your favorite way of creating blueprints. Despite some limitations, you can still get pretty creative with this approach.
